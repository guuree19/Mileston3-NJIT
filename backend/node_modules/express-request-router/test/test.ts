import * as assert from 'assert';
import * as http from 'http';
import * as express from 'express';
import * as request from 'request-promise-native';
import requestRouter from '../express-request-router';
import testRouter from './test-router';
import TestOptions from './test-options';

describe('RequestRouter', function () {
	this.timeout(15000);
	let server: http.Server = null;
	let host = 'http://localhost:' + TestOptions.SERVER_PORT;

	before(() => {
		let app = express();
		app.use('/', testRouter);
		app.use('/request', requestRouter);

		server = http.createServer(app);
		server.listen(TestOptions.SERVER_PORT);
	});

	it('Возвращает ожидаемый результат на GET-запрос.', async () => {
		let response = await request({
			url: host + '/request',
			method: 'post',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({ url: host })
		});
		assert.strictEqual(TestOptions.GET_ANSWER, response);
	});

	it('Возвращает ожидаемый результат на POST-запрос.', async () => {
		let response = await request({
			url: host + '/request',
			method: 'post',
			headers: {'Content-Type': 'application/json'},
			body: JSON.stringify({
				url: host,
				method: 'POST'
			})
		});
		assert.strictEqual(TestOptions.POST_ANSWER, response);
	});

	it('Добавляет заголовки указанные в параметре headers.', async () => {
		let response = await request({
			url: host + '/request',
			method: 'post',
			headers: {'Content-Type': 'application/json'},
			body: JSON.stringify({
				url: host + '/ping',
				headers: {'content-language': 'my'}
			})
		});
		response = JSON.parse(response);
		assert.ok('content-language' in response.headers);
		assert.strictEqual('my', response.headers['content-language']);
	});

	it('Добавляет правильное тело запроса, если оно указано.', async () => {
		let response = await request({
			url: host + '/request',
			method: 'post',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({
				url: host + '/ping',
				headers: {'Content-Type': 'text/plain'},
				body: 'мясцо'
			})
		});
		response = JSON.parse(response);
		assert.strictEqual('мясцо', response.body);
	});

	it('Устанавливает все заголовки, которые были указаны в ответе.', async () => {
		let response = await request({
			url: host + '/request',
			method: 'post',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({
				url: host + '/some-headers',
				method: 'get'
			}),
			resolveWithFullResponse: true
		});
		
		assert.ok('some-header' in response.headers);
		assert.strictEqual('some-value', response.headers['some-header']);
	});

	it('Устанавливает код ответа, который был получен в ответ.', async () => {
		try {
			let response = await request({
				url: host + '/request',
				method: 'post',
				headers: { 'Content-Type': 'application/json' },
				body: JSON.stringify({
					url: host + '/status-code-404',
					method: 'get'
				}),
				resolveWithFullResponse: true
			});
		}
		catch (error) {
			assert.strictEqual('StatusCodeError', error.name);
			assert.strictEqual(404, error.statusCode);
		}
	});

	it('Если в параметрах запроса указан прокси, то он используется.', async () => {
		let proxyInfo: { ip: string, curl: string } = await request({
			url: 'http://gimmeproxy.com/api/getProxy?protocol=http',
			json: true
		});

		let response = await request({
			url: host + '/request',
			method: 'post',
			headers: { 'Content-Type': 'application/json' },
			body: JSON.stringify({
				url: 'http://c98561uk.beget.tech/',
				proxy: proxyInfo.curl
			})
		});

		response = JSON.parse(response);
		assert.strictEqual(proxyInfo.ip, response.ip);
	});

	after(() => {
		server.close();
	});
});